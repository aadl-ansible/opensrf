<?xml version="1.0"?>
<!-- 
Example OpenSRF bootstrap configuration file for Evergreen
-->
<config>
  <!-- Options for <loglevel>: 0 None, 1 Error, 2 Warning, 3 Info, 4 debug -->
  <opensrf>
    <routers>

      <!-- define the list of routers our services will register with -->
      <router>
        <!-- 
          This is the public router.  On this router, we only register
          applications which should be accessible to everyone on the OpenSRF
          network
        -->
        <name>router</name>
        <domain>public.{{ inventory_hostname }}</domain>

        <services>
          <service>opensrf.math</service>
          <service>open-ils.actor</service>
          <service>open-ils.acq</service>
          <service>open-ils.auth</service>
          <service>open-ils.auth_proxy</service>
          <service>open-ils.booking</service>
          <service>open-ils.cat</service>
          <service>open-ils.circ</service>
          <service>open-ils.collections</service>
          <service>open-ils.fielder</service>
          <service>open-ils.pcrud</service>
          <service>open-ils.permacrud</service>
          <service>open-ils.reporter</service>
          <service>open-ils.resolver</service>
          <service>open-ils.search</service>
          <service>open-ils.supercat</service>
          <service>open-ils.url_verify</service>
          <service>open-ils.vandelay</service>
          <service>open-ils.serial</service>
          <service>open-ils.ebook_api</service>
        </services>
      </router>

      <router>
        <!--
          This is the private router.  All applications must register with 
          this router, so no explicit <services> section is required
        -->
        <name>router</name>
        <domain>private.{{ inventory_hostname }}</domain>
      </router>
    </routers>

    <!-- Our domain should match that of the private router -->
    <domain>private.{{ inventory_hostname }}</domain>
    <username>opensrf</username>
    <passwd>{{ opensrf_ejabberd_private_users.opensrf.password }}</passwd>
    <port>5222</port>

    <!-- 
      Name of the router used on our private domain.  
      This should match one of the <name> of the private router above.
     -->
    <router_name>router</router_name>

    <logfile>{{ opensrf_install_prefix }}/var/log/osrfsys.log</logfile>
    <!--
      <logfile>syslog</logfile>
      <syslog>local0</syslog>
      <actlog>local1</actlog>
     -->
    <loglevel>3</loglevel>
    <settings_config>{{ opensrf_install_prefix }}/conf/opensrf.xml</settings_config>
  </opensrf>
  <!-- 
    The section between <gateway>...</gateway> is a standard OpenSRF C
    stack configuration file
  -->
  <gateway>
    <client>true</client>
    <router_name>router</router_name>

    <!-- The gateway connects to the public domain for security -->
    <domain>public.{{ inventory_hostname }}</domain>

    <!-- This section will be soon deprecated for multi-domain mode... -->
    <services>
      <service>opensrf.math</service>
      <service>opensrf.dbmath</service>
      <service>open-ils.cat</service>
      <service>open-ils.search</service>
      <service>open-ils.circ</service>
      <service>open-ils.actor</service>
      <service>open-ils.auth</service>
      <service>open-ils.auth_proxy</service>
      <service>open-ils.collections</service>
      <service>open-ils.reporter</service>
    </services>

    <!-- jabber login info -->
    <username>opensrf</username>
    <passwd>{{ opensrf_ejabberd_public_users.opensrf.password }}</passwd>
    <port>5222</port>
    <loglevel>3</loglevel>
    <logfile>{{ opensrf_install_prefix }}/var/log/gateway.log</logfile>
    <!--
      <logfile>syslog</logfile>
      <syslog>local6</syslog>
      <actlog>local1</actlog>
    -->
  </gateway>
  <!-- ======================================================================================== -->
  <routers>
    <router>
      <!-- public router -->
      <trusted_domains>
        <!-- 
          Allow private services to register with this router 
          and public client to send requests to this router. 
        -->
        <server>private.{{ inventory_hostname }}</server>

        <!-- 
          Also allow private clients to send to the router so it
          can receive error messages
        -->
        <client>private.{{ inventory_hostname }}</client>
        <client>public.{{ inventory_hostname }}</client>

      </trusted_domains>
      <transport>
        <server>public.{{ inventory_hostname }}</server>
        <port>5222</port>
        <unixpath>{{ opensrf_install_prefix }}/var/sock/unix_sock</unixpath>
        <username>router</username>
        <password>{{ opensrf_ejabberd_public_users.router.password }}</password>
        <resource>router</resource>
        <connect_timeout>10</connect_timeout>
        <max_reconnect_attempts>5</max_reconnect_attempts>
      </transport>
      <logfile>{{ opensrf_install_prefix }}/var/log/router-public.log</logfile>
      <!--
        <logfile>syslog</logfile>
        <syslog>local2</syslog>
      -->
      <loglevel>2</loglevel>
    </router>
    <router>
      <!-- private router -->
      <trusted_domains>
        <server>private.{{ inventory_hostname }}</server>
        <!-- 
          Only clients on the private domain can send requests to this router
         -->
        <client>private.{{ inventory_hostname }}</client>
      </trusted_domains>
      <transport>
        <server>private.{{ inventory_hostname }}</server>
        <port>5222</port>
        <username>router</username>
        <password>{{ opensrf_ejabberd_private_users.router.password }}</password>
        <resource>router</resource>
        <connect_timeout>10</connect_timeout>
        <max_reconnect_attempts>5</max_reconnect_attempts>
      </transport>
      <logfile>{{ opensrf_install_prefix }}/var/log/router-private.log</logfile>
      <!--
        <logfile>syslog</logfile>
        <syslog>local2</syslog>
      -->
      <loglevel>2</loglevel>
    </router>
  </routers>
  <!-- ======================================================================================== -->

  <!-- Any methods which match any of these match_string node values will     
       have their params redacted from lower-level input logging.             
       Adjust these examples as needed. -->      
  <shared>
    <log_protect>
      <match_string>open-ils.auth.authenticate.verify</match_string>
      <match_string>open-ils.auth.authenticate.complete</match_string>
      <match_string>open-ils.auth.login</match_string>
      <match_string>open-ils.auth_proxy.login</match_string>
      <match_string>open-ils.actor.patron.password_reset.commit</match_string>
      <match_string>open-ils.actor.user.password</match_string>
      <match_string>open-ils.actor.user.username</match_string>
      <match_string>open-ils.actor.user.email</match_string>
      <match_string>open-ils.actor.patron.update</match_string>
      <match_string>open-ils.cstore.direct.actor.user.create</match_string>
      <match_string>open-ils.cstore.direct.actor.user.update</match_string>
      <match_string>open-ils.cstore.direct.actor.user.delete</match_string>
      <match_string>open-ils.search.z3950.apply_credentials</match_string>
    </log_protect>
  </shared>
</config>